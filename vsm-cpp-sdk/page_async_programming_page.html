
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Asynchronous programming framework &#8212; CPP VSM SDK  documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="_static/doxyrest-pygments.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/target-highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Automatic Service Discovery" href="page_service_discovery_page.html" />
    <link rel="prev" title="Device interface" href="page_vehicle_interface_page.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="index.html">
  <img src="_static/logo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="page_ucs_vsm_overview_page.html">
  Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="page_getting_started.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="page_ucs_vsm_manual_page.html">
  Manual
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="page_tutorials_page.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="page_license_page.html">
  License
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="global.html">
  Global Namespace
 </a>
</li>

    
    <li class="nav-item">
        <a class="nav-link nav-external" href="https://www.ugcs.com/">UgCS<i class="fas fa-external-link-alt"></i></a>
    </li>
    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/ugcs/vsm-cpp-sdk" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="page_vehicle_interface_page.html">
   Device interface
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Asynchronous programming framework
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="page_service_discovery_page.html">
   Automatic Service Discovery
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="page_ucs_vsm_protocol_page.html">
   UCS-VSM communications protocol
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_proto_page.html">
     ucs_vsm.proto
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_overview_page.html">
     Overview
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_registration_page.html">
     Vehicle registration with UCS
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_fields_page.html">
     Field types and semantics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_telemetry_page.html">
     Telemetry protocol
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_commands_page.html">
     UCS-VSM Commands
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_protocol_examples_page.html">
     UCS-VSM protocol example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="page_ucs_vsm_protocol_wire_format_page.html">
     UCS-VSM protocol wire format
    </a>
   </li>
  </ul>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#callbacks">
   Callbacks
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#enforcing-callback-prototype">
     Enforcing callback prototype
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#requests-and-contexts">
   Requests and contexts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#serving-contexts-in-dedicated-threads">
     Serving contexts in dedicated threads
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creating-own-processor">
     Creating own processor
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="asynchronous-programming-framework">
<span id="doxid-d4-da8-async-programming-page"></span><span id="index-0"></span><h1>Asynchronous programming framework<a class="headerlink" href="#asynchronous-programming-framework" title="Permalink to this headline">¶</a></h1>
<p>Since VSM interacts with physical devices (thus doing a lot of various I/O operations), handles communications with other UgCS components (UCS server), asynchronous programming paradigm concept is supported by most of operations implemented in VSMs. It allows convenient creation of event-based applications.</p>
<section id="callbacks">
<span id="doxid-d4-da8-async-programming-page-1callbacks-section"></span><h2>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h2>
<p>Callback is the simplest entity a VSM asynchronous programming framework. All asynchronous handlers are represented as callback objects (<a class="reference internal" href="class_ugcs_vsm_Callback-2.html#doxid-d6-d1e-classugcs-1-1vsm-1-1-callback"><span class="std std-ref">ugcs::vsm::Callback</span></a>). Such an object encapsulates the copy of a callable entity (function pointer, class method pointer, lambda, callable object) and copy of all arguments to it. It is similar to std::bind() but provides additional features, such as possibility to use non-copyable objects as arguments (using move semantic), change stored arguments value. Callback usually created by <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback()</span></a> function.</p>
<p>Let’s say there is a function to be used as callback:</p>
<pre class="highlight literal-block"><span></span><span class="cm">/* Target function for callback. */</span>
<span class="kt">int</span>
<span class="nf">Sample_callback_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Sample callback function, arg: %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>Note that a function can have a return value or may be returning void, depending on developer needs. Callback object can be created as follows:</p>
<pre class="highlight literal-block"><span></span><span class="k">auto</span> <span class="n">func_cbk</span> <span class="o">=</span> <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span><span class="n">Sample_callback_function</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span></pre>
<p>It binds value 10 as the argument for the callback. After that callback can be called (invoked, executed):</p>
<pre class="highlight literal-block"><a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback call result: %d&quot;</span><span class="p">,</span> <span class="n">func_cbk</span><span class="p">());</span></pre>
<p>This will output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">12</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">50.572</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="n">Sample</span> <span class="n">callback</span> <span class="n">function</span><span class="p">,</span> <span class="nl">arg</span><span class="p">:</span> <span class="mi">10</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">12</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">50.572</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span> <span class="n">Callback</span> <span class="n">call</span> <span class="nl">result</span><span class="p">:</span> <span class="mi">20</span>
</pre></div>
</div>
<p>Object method also can be bound as callback. Let’s say there is a class:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="n">Sample_class</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span>
    <span class="n">Sample_callback_method</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">{</span>
        <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Sample callback method, arg: %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre>
<p>Its method can be bound:</p>
<pre class="highlight literal-block"><span></span><span class="n">Sample_class</span> <span class="n">class_instance</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">method_cbk</span> <span class="o">=</span> <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sample_class</span><span class="o">::</span><span class="n">Sample_callback_method</span><span class="p">,</span>
                                     <span class="o">&amp;</span><span class="n">class_instance</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback call result: %d&quot;</span><span class="p">,</span> <span class="n">method_cbk</span><span class="p">());</span></pre>
<p>Note that the first argument after the method pointer should be a pointer to the class instance to bound the callback to. It may be a plain C++ pointer or any smart pointer (it should have pointer semantic dereferencing operator defined). The output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">13</span><span class="o">:</span><span class="mi">48</span><span class="o">:</span><span class="mf">15.843</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span> <span class="n">Sample</span> <span class="n">callback</span> <span class="n">method</span><span class="p">,</span> <span class="nl">arg</span><span class="p">:</span> <span class="mi">10</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">13</span><span class="o">:</span><span class="mi">48</span><span class="o">:</span><span class="mf">15.843</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">45</span><span class="p">]</span> <span class="n">Callback</span> <span class="n">call</span> <span class="nl">result</span><span class="p">:</span> <span class="mi">20</span>
</pre></div>
</div>
<p>Another callback target can be callable object i.e. instance of a class which has the function call operator overloaded:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="n">Callable_class</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

    <span class="n">Callable_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span>
        <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">int</span>
    <span class="k">operator</span> <span class="p">()(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Sample callback method, arg: %d&quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></pre>
<p>The callable object instance passed as the first parameter to <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a> function:</p>
<pre class="highlight literal-block"><span></span><span class="n">Callable_class</span> <span class="nf">callable_instance</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">callable_cbk</span> <span class="o">=</span> <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span><span class="n">callable_instance</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback call result: %d&quot;</span><span class="p">,</span> <span class="n">callable_cbk</span><span class="p">());</span></pre>
<p>C++ has built-in callable objects lambda functions which also can be used as callback target:</p>
<pre class="highlight literal-block"><span></span><span class="k">auto</span> <span class="n">lambda_cbk</span> <span class="o">=</span> <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">{</span>
        <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Sample lambda callback, arg: %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="mi">10</span><span class="p">);</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback call result: %d&quot;</span><span class="p">,</span> <span class="n">lambda_cbk</span><span class="p">());</span></pre>
<p>In all cases when some callable entity is used to create a callback, developer should ensure that the entity lifetime is not less than the created callback lifetime, otherwise the behavior of the application is not defined (usually crash). If plain pointer to a class instance is passed, make sure it is not deleted before the last callback instance is destroyed. In general usage of plain pointer should be avoided and some kind of <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr">smartpointers</a> used instead in order to automatically control objects lifetime.</p>
<section id="enforcing-callback-prototype">
<span id="doxid-d4-da8-async-programming-page-1enforcing-callback-prototype"></span><h3>Enforcing callback prototype<a class="headerlink" href="#enforcing-callback-prototype" title="Permalink to this headline">¶</a></h3>
<p>In the examples above callbacks are created with arbitrary prototypes. Usually the callback is passed to some API which stores it as a handler of some event. Often the event has some parameters which should be passed to the handler. Also the callback return value may be used for some purpose by the caller. So in this case the API may want to restrict prototypes for passed callbacks - especially to enforce the type of the return value and types for some number of the first mandatory arguments. These first arguments are then provided by the handler caller and may contain event parameters. All the rest arguments are bound to the user provided values as before.</p>
<p>Required callback prototype is specified via <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy"><span class="std std-ref">ugcs::vsm::Callback_proxy</span></a> object:</p>
<pre class="highlight literal-block"><span></span><span class="k">typedef</span> <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy"><span class="std std-ref">ugcs::vsm::Callback_proxy&lt;int, double&gt;</span></a><span></span> <span class="n">Sample_handler_type</span><span class="p">;</span></pre>
<p>The first template parameter defines callback return type (which also can be void) and the rest optional arguments are types the first enforced arguments the callback should be able to accept. In this example, the callback should return <em>int</em> and should have the first argument of <em>double</em> type. The rest arguments are defined by the user.</p>
<p>Now <em>Sample_handler_type</em> is the type for callback the API method can accept:</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span>
<span class="nf">Some_api_method</span><span class="p">(</span><span class="n">Sample_handler_type</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
    <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback result: %d&quot;</span><span class="p">,</span> <span class="n">handler</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="p">}</span></pre>
<p>Note that <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback()</span></a> returns object which type is dependent from user defined arguments. The <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy"><span class="std std-ref">ugcs::vsm::Callback_proxy</span></a> class is designed in such a way that it can be created from any callback object which has compatible prototype return value type and types of the specified number of the first arguments.</p>
<p>Now there is an API call which accepts callback with the enforced prototype. Since the enforced arguments occupy the same storage as the arguments specified by the user, some initial values should be provided to <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a> function. For a user it might be inconvenient to define these initial values because he/she does not know which values are suitable to be initial ones. Instead the API developer should provide a so called builder function which provides suitable initial values for the enforced arguments and hides them from the user. This is done by using <a class="reference internal" href="global.html#doxid-da-d05-callback-8h-1aa8f8b02e868d6b8ae25772a955b6d7d7"><span class="std std-ref">DEFINE_CALLBACK_BUILDER</span></a> macro:</p>
<pre class="highlight literal-block"><a class="reference internal" href="global.html#doxid-da-d05-callback-8h-1aa8f8b02e868d6b8ae25772a955b6d7d7"><span class="std std-ref">DEFINE_CALLBACK_BUILDER</span></a><span></span><span class="p">(</span><span class="n">Sample_handler_builder</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.14</span><span class="p">))</span></pre>
<p>It defines the function <em>Sample_handler_builder</em> which returns a callback with one enforced argument of type <em>double</em> and its initial value <em>3.14</em>.</p>
<p>Now the API user can utilize this builder function to create a callback suitable for passing to the API function:</p>
<pre class="highlight literal-block"><span></span><span class="k">auto</span> <span class="n">My_callback_target</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">enforced_arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_arg</span><span class="p">)</span>
    <span class="p">{</span>
        <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Callback called, enforced argument %f user argument %d&quot;</span><span class="p">,</span>
            <span class="n">enforced_arg</span><span class="p">,</span> <span class="n">user_arg</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">30</span><span class="p">;</span>
    <span class="p">};</span>
<span class="n">Some_api_method</span><span class="p">(</span><span class="n">Sample_handler_builder</span><span class="p">(</span><span class="n">My_callback_target</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span></pre>
<p>Here user provides only a custom argument of type <em>int</em> (10) and the enforced argument of type <em>double</em> is hidden at this moment.</p>
<p>The output is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">18</span><span class="o">:</span><span class="mi">26</span><span class="o">:</span><span class="mf">14.712</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">105</span><span class="p">]</span> <span class="n">Callback</span> <span class="n">called</span><span class="p">,</span> <span class="n">enforced</span> <span class="n">argument</span> <span class="mf">20.000000</span> <span class="n">user</span> <span class="n">argument</span> <span class="mi">10</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">01</span> <span class="mi">18</span><span class="o">:</span><span class="mi">26</span><span class="o">:</span><span class="mf">14.712</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">89</span><span class="p">]</span> <span class="n">Callback</span> <span class="nl">result</span><span class="p">:</span> <span class="mi">30</span>
</pre></div>
</div>
<p>Note that initial value of the enforced argument is replaced by a new value (<em>20</em>) at the time of handler invocation in <em>Some_api_method</em>. There is a possibility to preserve the current value of the enforced arguments by using <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy-1a9777aee410a7c87f26fd57a10247477f"><span class="std std-ref">ugcs::vsm::Callback_proxy::Invoke()</span></a> method. Before that the values can be set any number of times using <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy-1a891dd9644ddff55f4f834a23dde7c7fd"><span class="std std-ref">ugcs::vsm::Callback_proxy::Set_args()</span></a> and <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy-1ab628cbdc529e3666b9aecbe59bc4edd2"><span class="std std-ref">ugcs::vsm::Callback_proxy::Set_arg()</span></a> methods.</p>
</section>
</section>
<section id="requests-and-contexts">
<span id="doxid-d4-da8-async-programming-page-1requests-and-contexts-section"></span><h2>Requests and contexts<a class="headerlink" href="#requests-and-contexts" title="Permalink to this headline">¶</a></h2>
<p>The plain callbacks described above are just wrappers for user provided entry points. It is not enough for creating asynchronous processing workflow higher level abstractions are needed. Requests and contexts are designed for that purpose.</p>
<p>All potentially blocking operations in VSM SDK are implemented using asynchronous programming pattern. The diagram below illustrates a typical workflow for an asynchronous operation.</p>
<img alt="_images/async_workflow.png" src="_images/async_workflow.png" />
<a class="reference internal image-reference" href="_images/async_workflow.png"><img alt="Asynchronous workflow" src="_images/async_workflow.png" style="width: 18px;" /></a>
<p>By “context” there is meant an execution context in which the processing or completion notification handler (i.e. callback) is executed. The framework provides ability to run contexts in any threads and time moments. For example, there can be several contexts which can be run explicitly in the current thread by calling <a class="reference internal" href="class_ugcs_vsm_Request_container_Request_waiter.html#doxid-d1-d94-classugcs-1-1vsm-1-1-request-container-1-1-request-waiter-1a74b1331d9dfe058530c2e8b922a03eb6"><span class="std std-ref">ugcs::vsm::Request_waiter::Wait_and_process()</span></a> method, or have a dedicated thread wrapped in the convenience class <a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker"><span class="std std-ref">ugcs::vsm::Request_worker</span></a> for running of contexts. Typically request processors (a component or service which processes a user request) has its own execution context usually served in a dedicated thread. Completion context is the one which will handle the request completion notification. In the diagram below user context (i.e. from which the request was initiated) is different from desired completion context. Often the user code may be running in the same context which is provided as completion context for a request. However in some cases it could be desirable to process notification in different context and the SDK provides such ability.</p>
<p>Simple example of the workflow:</p>
<pre class="highlight literal-block"><span></span><span class="cm">/* Create waiter object for our contexts. */</span>
<a class="reference internal" href="class_ugcs_vsm_Request_container_Request_waiter.html#doxid-d1-d94-classugcs-1-1vsm-1-1-request-container-1-1-request-waiter-1a3d3b944e71e1b2c4bb50a670bf5502d4"><span class="std std-ref">ugcs::vsm::Request_waiter::Ptr</span></a><span></span> <span class="n">waiter</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request_waiter.html#doxid-d1-d94-classugcs-1-1vsm-1-1-request-container-1-1-request-waiter-1a091f8971c953ca128e84d91567b00b52"><span class="std std-ref">ugcs::vsm::Request_waiter::Create</span></a><span></span><span class="p">();</span>
<span class="cm">/* Create processor for requests. */</span>
<a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1a470f700b033c20641c2076b2e76b9ccf"><span class="std std-ref">ugcs::vsm::Request_processor::Ptr</span></a><span></span> <span class="n">processor</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1aa503edaf7008fa1a923113518e074018"><span class="std std-ref">ugcs::vsm::Request_processor::Create</span></a><span></span><span class="p">(</span><span class="s">&quot;Processor&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span>
<span class="cm">/* Create completion context for notifications processing. */</span>
<a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1a470f700b033c20641c2076b2e76b9ccf"><span class="std std-ref">ugcs::vsm::Request_completion_context::Ptr</span></a><span></span> <span class="n">comp_ctx</span> <span class="o">=</span>
        <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1aa503edaf7008fa1a923113518e074018"><span class="std std-ref">ugcs::vsm::Request_completion_context::Create</span></a><span></span><span class="p">(</span><span class="s">&quot;Completion context&quot;</span><span class="p">,</span> <span class="n">waiter</span><span class="p">);</span></pre>
<p>Instances of processor and completion contexts are created. In this example they will run in one execution context so they will share one <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1a6df49f1cd8c0bee4e2575bc29e3e683a"><span class="std std-ref">ugcs::vsm::Request_waiter</span></a> object which is responsible for contexts synchronization. Note that the creation is done by static member function <em>Create()</em> and a smart pointer is returned to the user. This is a common approach for the most high-level objects in the SDK. The returned pointer is <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> instance so that the object is automatically destroyed when the last reference is released (no more pointer instances existing).</p>
<p>After the instances are created, they should be enabled to be able to accept requests.</p>
<pre class="highlight literal-block"><span></span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span>
<span class="n">comp_ctx</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span></pre>
<p>Now a request can be created:</p>
<pre class="highlight literal-block"><a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">req</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a342da78756478193a27cc412074fb79f"><span class="std std-ref">ugcs::vsm::Request::Create</span></a><span></span><span class="p">();</span>
<span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_processing_handler</span><span class="p">(</span>
    <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">req</span><span class="p">)</span>
        <span class="p">{</span>
            <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Processing handler called, arg %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
            <span class="n">req</span><span class="o">-&gt;</span><span class="n">Complete</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">10</span><span class="p">,</span> <span class="n">req</span><span class="p">));</span>
<span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_completion_handler</span><span class="p">(</span><span class="n">comp_ctx</span><span class="p">,</span>
    <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
        <span class="p">{</span>
            <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Completion notification handler called, arg %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">20</span><span class="p">));</span></pre>
<p>At least a processing handler should be mandatory assigned to the request. A completion handler is optional if it is not provided the request will be processed and no notification is issued. The request pointer is passed as a processing handler parameter. <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a38c68dcf1ed20975e2a2c25ac1610d40"><span class="std std-ref">ugcs::vsm::Request::Complete()</span></a> method should be called at some point when the request processing is completed. It is not mandatory to call it in the processing handler a particular processor can store it somewhere in its internal structures and complete the request later, e.g. when some I/O operation is completed. Note that the completion context is provided among with a completion callback in <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a12ec980ffc633959aed0359cd42536b8"><span class="std std-ref">ugcs::vsm::Request::Set_completion_handler()</span></a> method. Context for request processing is depending from the processor the request will be submitted to:</p>
<pre class="highlight literal-block"><span></span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">Submit_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Request submitted&quot;</span><span class="p">);</span></pre>
<p>Now the request is submitted to the processor requests queue. If it would be running in a separate thread, it could be processed in background asynchronously. But in the example there is no processor dedicated thread, so processing should be done explicitly:</p>
<pre class="highlight literal-block"><a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Before processor running&quot;</span><span class="p">);</span>
<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">Wait_and_process</span><span class="p">({</span><span class="n">processor</span><span class="p">});</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;After processor running&quot;</span><span class="p">);</span></pre>
<p><a class="reference internal" href="class_ugcs_vsm_Request_container_Request_waiter.html#doxid-d1-d94-classugcs-1-1vsm-1-1-request-container-1-1-request-waiter-1a74b1331d9dfe058530c2e8b922a03eb6"><span class="std std-ref">ugcs::vsm::Request_waiter::Wait_and_process()</span></a> method accepts a list of containers which should be served. It could accept both the processor and completion context here but for illustrative reasons only processor is provided. In the context of this call the processing handler will be called where <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a38c68dcf1ed20975e2a2c25ac1610d40"><span class="std std-ref">ugcs::vsm::Request::Complete()</span></a> method places the request in the completed state into completion context queue. It can be served now:</p>
<pre class="highlight literal-block"><a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Before completion context running&quot;</span><span class="p">);</span>
<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">Wait_and_process</span><span class="p">({</span><span class="n">comp_ctx</span><span class="p">});</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;After completion context running&quot;</span><span class="p">);</span></pre>
<p>The completion handler is called in this context and the request is fully processed after that.</p>
<p>When contexts are not longer needed they should be terminated by <a class="reference internal" href="class_ugcs_vsm_Request_container.html#doxid-d3-d1f-classugcs-1-1vsm-1-1-request-container-1aa68b072400c148d77a5fab4529e68d8e"><span class="std std-ref">ugcs::vsm::Request_container::Disable()</span></a> method:</p>
<pre class="highlight literal-block"><span></span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span>
<span class="n">comp_ctx</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span></pre>
<p>Many of SDK classes have Enable()/Disable() methods. One could think they are redundant, because class destructors can do the clean up work but it is not true. C++ does not have the garbage collector so even when using smart pointers there could be cyclic references between objects. And when the last external (from developer point of view) reference is released, internal references could still exist and form so called isolation islands preventing destructor calling. In the managed languages like Java and Python the garbage collector runs in the background and detects and destroys such islands. In C++ it is not possible, so developer still needs to keep in mind possible cyclic references and break them manually before reference releasing. One of the most important functions of Disable() methods in the SDK classes is breaking internal cyclic references to avoid memory leaks.</p>
<p>The output of this example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">148</span><span class="p">]</span> <span class="n">Request</span> <span class="n">submitted</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">152</span><span class="p">]</span> <span class="n">Before</span> <span class="n">processor</span> <span class="n">running</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">135</span><span class="p">]</span> <span class="n">Processing</span> <span class="n">handler</span> <span class="n">called</span><span class="p">,</span> <span class="n">arg</span> <span class="mi">10</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">154</span><span class="p">]</span> <span class="n">After</span> <span class="n">processor</span> <span class="n">running</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">158</span><span class="p">]</span> <span class="n">Before</span> <span class="n">completion</span> <span class="n">context</span> <span class="n">running</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">142</span><span class="p">]</span> <span class="n">Completion</span> <span class="n">notification</span> <span class="n">handler</span> <span class="n">called</span><span class="p">,</span> <span class="n">arg</span> <span class="mi">20</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">13</span><span class="o">:</span><span class="mi">54</span><span class="o">:</span><span class="mf">10.618</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">160</span><span class="p">]</span> <span class="n">After</span> <span class="n">completion</span> <span class="n">context</span> <span class="n">running</span>
</pre></div>
</div>
<section id="serving-contexts-in-dedicated-threads">
<span id="doxid-d4-da8-async-programming-page-1serving-in-sep-threads"></span><h3>Serving contexts in dedicated threads<a class="headerlink" href="#serving-contexts-in-dedicated-threads" title="Permalink to this headline">¶</a></h3>
<p>Previous example can be modified so that processor and completion contexts are served by a separate thread. This is quite typical task so the convenience class exists <a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker"><span class="std std-ref">ugcs::vsm::Request_worker</span></a>.</p>
<pre class="highlight literal-block"><span></span><span class="cm">/* Demonstrate contexts serving in a separated thread. */</span>
<a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker-1a24f61987e7b9b6cfd179e9a1c86125de"><span class="std std-ref">ugcs::vsm::Request_worker::Ptr</span></a><span></span> <span class="n">worker</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker-1abe7b9cf9d6e427c71e7c1e52d373b527"><span class="std std-ref">ugcs::vsm::Request_worker::Create</span></a><span></span><span class="p">(</span><span class="s">&quot;Another thread&quot;</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">ugcs</span><span class="o">::</span><span class="n">vsm</span><span class="o">::</span><span class="n">Request_container</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">{</span><span class="n">processor</span><span class="p">,</span> <span class="n">comp_ctx</span><span class="p">});</span>
<span class="cm">/* Enable all attached containers. */</span>
<span class="n">worker</span><span class="o">-&gt;</span><span class="n">Enable_containers</span><span class="p">();</span>
<span class="cm">/* Enable the worker. This will launch its thread. */</span>
<span class="n">worker</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span></pre>
<p>Here a worker object is created and contexts are attached to it.</p>
<p><a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker"><span class="std std-ref">ugcs::vsm::Request_worker</span></a> object itself is a completion context and is served similarly as the attached contexts.</p>
<p>After that the attached containers are enabled as well as the worker object itself. When it is done a separate thread is spawned where all the attached containers are served. Request submitted to the processor will be executed in the worker thread.</p>
<pre class="highlight literal-block"><span></span><span class="n">req</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a342da78756478193a27cc412074fb79f"><span class="std std-ref">ugcs::vsm::Request::Create</span></a><span></span><span class="p">();</span>
<span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_processing_handler</span><span class="p">(</span>
    <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">req</span><span class="p">)</span>
        <span class="p">{</span>
            <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Processing handler called, arg %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
            <span class="n">req</span><span class="o">-&gt;</span><span class="n">Complete</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">10</span><span class="p">,</span> <span class="n">req</span><span class="p">));</span>
<span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_completion_handler</span><span class="p">(</span><span class="n">comp_ctx</span><span class="p">,</span>
    <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
        <span class="p">{</span>
            <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Completion notification handler called, arg %d&quot;</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">20</span><span class="p">));</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Before request submission&quot;</span><span class="p">);</span>
<span class="n">processor</span><span class="o">-&gt;</span><span class="n">Submit_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
<span class="cm">/* Give a chance to process the request in a parallel thread. */</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;After request submission&quot;</span><span class="p">);</span>

<span class="cm">/* Disable attached containers and the worker itself. */</span>
<span class="n">worker</span><span class="o">-&gt;</span><span class="n">Disable_containers</span><span class="p">();</span>
<span class="n">worker</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span></pre>
<p>The output is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">14</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">54.690</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">193</span><span class="p">]</span> <span class="n">Before</span> <span class="n">request</span> <span class="n">submission</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">14</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">54.690</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">184</span><span class="p">]</span> <span class="n">Processing</span> <span class="n">handler</span> <span class="n">called</span><span class="p">,</span> <span class="n">arg</span> <span class="mi">10</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">14</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">54.690</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">191</span><span class="p">]</span> <span class="n">Completion</span> <span class="n">notification</span> <span class="n">handler</span> <span class="n">called</span><span class="p">,</span> <span class="n">arg</span> <span class="mi">20</span>
<span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">14</span><span class="o">:</span><span class="mi">09</span><span class="o">:</span><span class="mf">55.690</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">197</span><span class="p">]</span> <span class="n">After</span> <span class="n">request</span> <span class="n">submission</span>
</pre></div>
</div>
<p>As it is seen the both processing and completion handlers were called right after submission. It was done in a separate worker thread.</p>
</section>
<section id="creating-own-processor">
<span id="doxid-d4-da8-async-programming-page-1creating-own-processor-section"></span><h3>Creating own processor<a class="headerlink" href="#creating-own-processor" title="Permalink to this headline">¶</a></h3>
<p>In the previous example <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1aaf87aa8291eb8db5efaf3dd1c72153cf"><span class="std std-ref">ugcs::vsm::Request_processor</span></a> class was used to process requests. But actually this class does not provide any useful service. All the processing was done by a processing handler provided by the user. This is not a usual pattern because processors are created for providing some service like I/O with some device or network. So they will have their own processing handlers which do the stuff. Also request creation is the thing the user is not supposed to do. The processor usually provides methods which accept request parameters and a result handler with a completion context. The request creation is done inside the processor. Simplest typical processor declaration looks as follows:</p>
<pre class="highlight literal-block"><span></span><span class="k">class</span> <span class="nl">Sample_processor</span><span class="p">:</span> <span class="k">public</span> <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context"><span class="std std-ref">ugcs::vsm::Request_processor</span></a><span></span> <span class="p">{</span>
    <a class="reference internal" href="global.html#doxid-d5-d60-utils-8h-1add7ad4e26c0e697e6eadb8da66c3e60d"><span class="std std-ref">DEFINE_COMMON_CLASS</span></a><span></span><span class="p">(</span><span class="n">Sample_processor</span><span class="p">,</span> <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context"><span class="std std-ref">ugcs::vsm::Request_processor</span></a><span></span><span class="p">)</span>
<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* Type for result handler. */</span>
    <span class="k">typedef</span> <a class="reference internal" href="class_ugcs_vsm_Callback_proxy.html#doxid-d0-db9-classugcs-1-1vsm-1-1-callback-proxy"><span class="std std-ref">ugcs::vsm::Callback_proxy&lt;void, double&gt;</span></a><span></span> <span class="n">Handler</span><span class="p">;</span>
    <span class="cm">/* Builder for handler. */</span>
    <a class="reference internal" href="global.html#doxid-da-d05-callback-8h-1aa8f8b02e868d6b8ae25772a955b6d7d7"><span class="std std-ref">DEFINE_CALLBACK_BUILDER</span></a><span></span><span class="p">(</span><span class="n">Make_handler</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.14</span><span class="p">));</span>

    <span class="n">Sample_processor</span><span class="p">()</span> <span class="o">:</span> <a class="reference internal" href="namespace_ugcs.html#doxid-d1-d6b-namespaceugcs"><span class="std std-ref">ugcs</span></a><span></span><span class="o">::</span><span class="n">vsm</span><span class="o">::</span><a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1aaf87aa8291eb8db5efaf3dd1c72153cf"><span class="std std-ref">Request_processor</span></a><span></span><span class="p">(</span><span class="s">&quot;Sample processor&quot;</span><span class="p">)</span> <span class="p">{}</span>

    <span class="cm">/* The method for accessing processor provided services. */</span>
    <a class="reference internal" href="class_ugcs_vsm_Operation_waiter.html#doxid-d0-d74-classugcs-1-1vsm-1-1-operation-waiter"><span class="std std-ref">ugcs::vsm::Operation_waiter</span></a><span></span>
    <span class="n">Sample_api_method</span><span class="p">(</span><span class="cm">/* Some request parameter. */</span>
                      <span class="kt">int</span> <span class="n">param</span><span class="p">,</span>
                      <span class="cm">/* Result handler. Default one does nothing thus discarding</span>
<span class="cm">                       * the result.</span>
<span class="cm">                       */</span>
                      <span class="n">Handler</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">ugcs</span><span class="o">::</span><span class="n">vsm</span><span class="o">::</span><span class="n">Make_dummy_callback</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span>
                      <span class="cm">/* Completion context for result handler invocation. Default</span>
<span class="cm">                       * value will use processor context.</span>
<span class="cm">                       */</span>
                      <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1a470f700b033c20641c2076b2e76b9ccf"><span class="std std-ref">ugcs::vsm::Request_completion_context::Ptr</span></a><span></span> <span class="n">comp_ctx</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="cm">/* Default completion context if the caller does not provide own one. */</span>
    <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1a470f700b033c20641c2076b2e76b9ccf"><span class="std std-ref">ugcs::vsm::Request_completion_context::Ptr</span></a><span></span> <span class="n">def_comp_ctx</span><span class="p">;</span>
    <span class="cm">/* Worker with dedicated thread for this processor. */</span>
    <a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker-1a24f61987e7b9b6cfd179e9a1c86125de"><span class="std std-ref">ugcs::vsm::Request_worker::Ptr</span></a><span></span> <span class="n">worker</span><span class="p">;</span>

    <span class="cm">/* Request processing handler. It is always invoked in the processor dedicated thread. */</span>
    <span class="kt">void</span>
    <span class="n">Process_api_call</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">,</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">request</span><span class="p">,</span> <span class="n">Handler</span> <span class="n">handler</span><span class="p">);</span>

    <span class="cm">/* Called when the processor is enabled. */</span>
    <span class="k">virtual</span> <span class="kt">void</span>
    On_enable<span></span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/* Called when the processor is enabled. */</span>
    <span class="k">virtual</span> <span class="kt">void</span>
    On_disable<span></span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span></pre>
<p>All processors should be derived from <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1aaf87aa8291eb8db5efaf3dd1c72153cf"><span class="std std-ref">ugcs::vsm::Request_processor</span></a> class. Also the convenience macro <a class="reference internal" href="global.html#doxid-d5-d60-utils-8h-1add7ad4e26c0e697e6eadb8da66c3e60d"><span class="std std-ref">DEFINE_COMMON_CLASS</span></a> is used to create some typical methods (like Create()) and types (like Ptr). This processor service is available via <em>Sample_api_method()</em>. The result is returned via a result handler which may be provided as the method argument. The handler type has the restricted prototype with the corresponding builder method. Member <em>def_comp_ctx</em> is default completion context which is used when the user does not provide one. Also the processor has <em>worker</em> member in order to have its own dedicated thread.</p>
<p>Methods <em>On_enable()</em> and <em>On_disable()</em> are called by the framework when the processor is enabled or disabled. They may be overridden if the custom processor needs to intercept these events. Possible implementation:</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span>
<span class="n">Sample_processor</span><span class="o">::</span><span class="n">On_enable</span><span class="p">()</span>
<span class="p">{</span>
    ugcs::vsm::Request_processor::On_enable<span></span><span class="p">();</span>
    <span class="n">def_comp_ctx</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1aa503edaf7008fa1a923113518e074018"><span class="std std-ref">ugcs::vsm::Request_completion_context::Create</span></a><span></span><span class="p">(</span><span class="s">&quot;Completion context&quot;</span><span class="p">);</span>
    <span class="n">def_comp_ctx</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span>
    <span class="n">worker</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_worker.html#doxid-d4-dcf-classugcs-1-1vsm-1-1-request-worker-1abe7b9cf9d6e427c71e7c1e52d373b527"><span class="std std-ref">ugcs::vsm::Request_worker::Create</span></a><span></span><span class="p">(</span><span class="s">&quot;Worker&quot;</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">ugcs</span><span class="o">::</span><span class="n">vsm</span><span class="o">::</span><span class="n">Request_container</span><span class="o">::</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">{</span><span class="n">Shared_from_this</span><span class="p">(),</span> <span class="n">def_comp_ctx</span><span class="p">});</span>
    <span class="n">worker</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Sample_processor</span><span class="o">::</span><span class="n">On_disable</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Set_disabled</span><span class="p">();</span>
    <span class="n">worker</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span>
    <span class="n">def_comp_ctx</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span>
    <span class="n">def_comp_ctx</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>Worker is created with the processor itself and default completion context attached. Note that the base class methods also should be called.</p>
<pre class="highlight literal-block"><a class="reference internal" href="class_ugcs_vsm_Operation_waiter.html#doxid-d0-d74-classugcs-1-1vsm-1-1-operation-waiter"><span class="std std-ref">ugcs::vsm::Operation_waiter</span></a><span></span>
<span class="n">Sample_processor</span><span class="o">::</span><span class="n">Sample_api_method</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">,</span>
                                    <span class="n">Handler</span> <span class="n">handler</span><span class="p">,</span>
                                    <a class="reference internal" href="class_ugcs_vsm_Request_context.html#doxid-d7-dcd-classugcs-1-1vsm-1-1-request-context-1a470f700b033c20641c2076b2e76b9ccf"><span class="std std-ref">ugcs::vsm::Request_completion_context::Ptr</span></a><span></span> <span class="n">comp_ctx</span><span class="p">)</span>
<span class="p">{</span>
    <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">req</span> <span class="o">=</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a342da78756478193a27cc412074fb79f"><span class="std std-ref">ugcs::vsm::Request::Create</span></a><span></span><span class="p">();</span>
    <span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_processing_handler</span><span class="p">(</span>
        <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1ad0409b84278bc4bc1c8db2c993681dad"><span class="std std-ref">ugcs::vsm::Make_callback</span></a><span></span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sample_processor</span><span class="o">::</span><span class="n">Process_api_call</span><span class="p">,</span> <span class="n">Shared_from_this</span><span class="p">(),</span>
                           <span class="n">param</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">handler</span><span class="p">));</span>
    <span class="n">req</span><span class="o">-&gt;</span><span class="n">Set_completion_handler</span><span class="p">(</span><span class="n">comp_ctx</span> <span class="o">?</span> <span class="nl">comp_ctx</span> <span class="p">:</span> <span class="n">def_comp_ctx</span><span class="p">,</span>
                                <span class="n">handler</span><span class="p">);</span>
    <span class="n">Submit_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">req</span><span class="p">;</span>
<span class="p">}</span></pre>
<p>This is a typical implementation of an API call a new request is created and own private method is assigned as a processing handler with all necessary arguments enclosed. Usually a request itself also should be enclosed among with the call parameters. The user provided handler is passed in order to provide ability to set the result there later. An alternative approach may be to create own request type which is derived from <a class="reference internal" href="namespace_ugcs_vsm.html#doxid-dd-def-namespaceugcs-1-1vsm-1a98ac69eea094e0fbb1a059fc0b03d7f4"><span class="std std-ref">ugcs::vsm::Request</span></a> class and store all parameters there.</p>
<p>Completion handler is the one specified by the user and either default or user specified completion context.</p>
<p>The request is then submitted to the processor itself.</p>
<p>The call returns <a class="reference internal" href="class_ugcs_vsm_Operation_waiter.html#doxid-d0-d74-classugcs-1-1vsm-1-1-operation-waiter"><span class="std std-ref">ugcs::vsm::Operation_waiter</span></a> object which is user handle for the request. It can be used, for example, to synchronize with the request execution or to cancel it.</p>
<p>Now the request processing method implementation:</p>
<pre class="highlight literal-block"><span></span><span class="kt">void</span>
<span class="n">Sample_processor</span><span class="o">::</span><span class="n">Process_api_call</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">,</span> <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a9fc856a23cf576b01649cabc8a6ce3ec"><span class="std std-ref">ugcs::vsm::Request::Ptr</span></a><span></span> <span class="n">request</span><span class="p">,</span>
                                   <span class="n">Handler</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">Is_processing</span><span class="p">())</span> <span class="p">{</span>
        <span class="cm">/* It might be canceled. */</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">handler</span><span class="p">.</span><span class="n">Set_args</span><span class="p">(</span><span class="n">param</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">request</span><span class="o">-&gt;</span><span class="n">Complete</span><span class="p">(</span><a class="reference internal" href="enum_ugcs_vsm_Request_container_Request_Status.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a7e8d9e205f783c829fcb5bdda00f6f76ae0aa021e21dddbd6d8cecec71e9cf564"><span class="std std-ref">ugcs::vsm::Request::Status::OK</span></a><span></span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span></pre>
<p>It is called in the processor thread and there is no concurrency with other requests all of them are serialized in the processor requests queue. In many cases it significantly simplifies the processor design by eliminating parallel programming problems like locking and any other kind of synchronization in case all the work is done in a processor context which is a single thread.</p>
<p>The lock to the request is acquired since the request state may be changed from some other thread (e.g. request may be canceled). Under the lock the request state is checked and the argument for the user completion handler is set actually it is the the API call result. After it is done, the request is completed by calling <a class="reference internal" href="class_ugcs_vsm_Request_container_Request.html#doxid-d2-d26-classugcs-1-1vsm-1-1-request-container-1-1-request-1a38c68dcf1ed20975e2a2c25ac1610d40"><span class="std std-ref">ugcs::vsm::Request::Complete()</span></a> method. The lock is passed there to make it atomically.</p>
<p>Now the simplest custom processor is fully defined and can be tested.</p>
<pre class="highlight literal-block"><span></span><span class="n">Sample_processor</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">Sample_processor</span><span class="o">::</span><span class="n">Create</span><span class="p">();</span>
<span class="n">processor</span><span class="o">-&gt;</span><span class="n">Enable</span><span class="p">();</span>

<span class="k">auto</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">Sample_processor</span><span class="o">::</span><span class="n">Make_handler</span><span class="p">(</span>
    <span class="p">[](</span><span class="kt">double</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_param</span><span class="p">)</span>
    <span class="p">{</span>
        <a class="reference internal" href="global.html#doxid-d7-d7f-log-8h-1a159ca84d25a5487d8e81e4438725df19"><span class="std std-ref">LOG</span></a><span></span><span class="p">(</span><span class="s">&quot;Request completed, result %f, user param %d&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">user_param</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">30</span><span class="p">);</span>
<span class="n">processor</span><span class="o">-&gt;</span><span class="n">Sample_api_method</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
<span class="cm">/* Give a chance to process the request in a parallel thread. */</span>
<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="n">processor</span><span class="o">-&gt;</span><span class="n">Disable</span><span class="p">();</span></pre>
<p>The output is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">2013</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">02</span> <span class="mi">17</span><span class="o">:</span><span class="mi">40</span><span class="o">:</span><span class="mf">52.873</span> <span class="o">-</span> <span class="o">&lt;</span><span class="n">DEBUG</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">async_workflow</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">312</span><span class="p">]</span> <span class="n">Request</span> <span class="n">completed</span><span class="p">,</span> <span class="n">result</span> <span class="mf">20.000000</span><span class="p">,</span> <span class="n">user</span> <span class="n">param</span> <span class="mi">30</span>
</pre></div>
</div>
<p>There is the source for all examples in this article: <a class="reference internal" href="example_async_workflow.cpp.html#doxid-d8-d89-async-workflow-8cpp-example"><span class="std std-ref">async_workflow.cpp</span></a></p>
</section>
</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="page_vehicle_interface_page.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Device interface</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="page_service_discovery_page.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Automatic Service Discovery</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2020, SPH Engineering.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>